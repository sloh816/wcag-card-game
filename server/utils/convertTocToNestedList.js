// generated by Claude AI

const cheerio = require("cheerio");

function convertTocToNestedList(htmlString) {
	// Load the HTML string with cheerio
	const $ = cheerio.load(htmlString);

	// Get all elements (not just TOC items) to preserve order
	const allElements =
		$("body").children().length > 0 ? $("body").children() : $(":root").children();

	let result = "";
	let currentTocGroup = [];
	let insideTocGroup = false;

	// Helper function to process a group of consecutive TOC items
	function processTocGroup(tocItems) {
		if (tocItems.length === 0) return "";

		const stack = [];
		let tocResult = "<ul class='toc-list'>\n";
		let currentLevel = null;

		tocItems.forEach((item) => {
			const levelMatch = item.className.match(/toc-(\d+)/);
			if (!levelMatch) return;

			const level = parseInt(levelMatch[1]);
			const { href, text, className } = item;

			// If this is the first item or same level as previous
			if (currentLevel === null || level === currentLevel) {
				// Close any deeper nested lists
				while (stack.length > 0 && stack[stack.length - 1].level >= level) {
					const closed = stack.pop();
					tocResult += "    ".repeat(closed.level - 1) + "</ul>\n";
					tocResult += "    ".repeat(closed.level - 1) + "</li>\n";
				}

				// Add the list item
				const indent = "    ".repeat(level - 1);
				tocResult += `${indent}<li class="${className}"><a href="${href}">${text}</a>`;

				currentLevel = level;
			}
			// If this is a deeper level (sub-item)
			else if (level > currentLevel) {
				// Start a new nested list
				tocResult += "\n";
				const indent = "    ".repeat(level - 1);
				tocResult += `${indent}<ul>\n`;
				tocResult += `${indent}    <li class="${className}"><a href="${href}">${text}</a>`;

				// Push current level to stack
				stack.push({ level: currentLevel, hasNestedList: true });
				currentLevel = level;
			}
			// If this is a shallower level (back to parent level)
			else if (level < currentLevel) {
				// Close nested lists until we reach the right level
				while (stack.length > 0 && stack[stack.length - 1].level >= level) {
					const closed = stack.pop();
					tocResult += "\n";
					tocResult += "    ".repeat(closed.level) + "</ul>\n";
					tocResult += "    ".repeat(closed.level - 1) + "</li>\n";
				}

				// Add the new item at the correct level
				const indent = "    ".repeat(level - 1);
				tocResult += `${indent}<li class="${className}"><a href="${href}">${text}</a>`;

				currentLevel = level;
			}
		});

		// Close any remaining open nested lists
		while (stack.length > 0) {
			const closed = stack.pop();
			tocResult += "\n";
			tocResult += "    ".repeat(closed.level) + "</ul>\n";
			tocResult += "    ".repeat(closed.level - 1) + "</li>\n";
		}

		// Close the final list item and main list
		tocResult += "</li>\n";
		tocResult += "</ul>\n";

		return tocResult;
	}

	// Process all elements in order
	allElements.each((index, element) => {
		const $el = $(element);
		const tagName = element.tagName.toLowerCase();
		const className = $el.attr("class") || "";

		// Check if this is a TOC item
		if (tagName === "p" && className.match(/toc-\d+/)) {
			const $anchor = $el.find("a");
			if ($anchor.length > 0) {
				// Add to current TOC group
				currentTocGroup.push({
					href: $anchor.attr("href"),
					text: $anchor.text(),
					className: className
				});
				insideTocGroup = true;
				return; // Don't add this element to result yet
			}
		}

		// If we hit a non-TOC element and we have a TOC group, process it
		if (insideTocGroup && currentTocGroup.length > 0) {
			result += processTocGroup(currentTocGroup);
			currentTocGroup = [];
			insideTocGroup = false;
		}

		// Add the non-TOC element to result
		result += $.html($el) + "\n";
	});

	// Process any remaining TOC group at the end
	if (currentTocGroup.length > 0) {
		result += processTocGroup(currentTocGroup);
	}

	return result.trim();
}

module.exports = convertTocToNestedList;
