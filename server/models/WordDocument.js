const fileSystem = require("../utils/fileSystem");
const writeImageFiles = require("../utils/writeImageFiles");
const { slugify, repeatString } = require("../utils/strings");
const mammoth = require("mammoth");
const xml2js = require("xml2js");
const Html = require("./Html");
const fs = require("fs");
const cheerio = require("cheerio");
const emuToPx = require("../utils/emuToPx");
const { Block } = require("@mui/icons-material");

class WordDocument {
	constructor(filePath) {
		this.filePath = filePath;
		this.unzippedFolder = null;
	}

	async unzip() {
		// create a folder for the word document in the unzippedWordDocs directory
		const unzippedFolder = await fileSystem.createFolder(
			"server/lib/unzippedWordDocs/" + this.filePath.split("/").pop().replace(".docx", "")
		);

		// copy word doc to folder
		const wordDoc = await fileSystem.copyFile(
			this.filePath,
			unzippedFolder + "/" + this.filePath.split("/").pop()
		);

		// covert to zip file
		const zipFilePath = wordDoc.replace(".docx", ".zip");
		await fileSystem.renameFile(wordDoc, zipFilePath);

		// unzip the file
		await fileSystem.unzipFile(zipFilePath, unzippedFolder);

		// remove the zip file
		await fileSystem.deleteFile(zipFilePath);

		this.unzippedFolder = unzippedFolder;
	}

	async generateStyleMap() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		// read the styles.xml file from the unzipped Word document
		const parser = new xml2js.Parser();
		const stylesXmlPath = this.unzippedFolder + "/word/styles.xml";
		const stylesXmlContent = await fileSystem.readFile(stylesXmlPath);
		const stylesObject = await parser.parseStringPromise(stylesXmlContent);

		// read the numbering.xml file from the unzipped Word document
		const numberingXmlPath = this.unzippedFolder + "/word/numbering.xml";
		const numberingXmlContent = await fileSystem.readFile(numberingXmlPath);
		const numberingObject = await parser.parseStringPromise(numberingXmlContent);

		const styles = stylesObject["w:styles"]["w:style"];

		const styleMap = [];
		for (const style of styles) {
			let skipStyle = false;

			const name = style["w:name"][0]["$"]["w:val"];
			const styleType = style["$"]["w:type"] || "paragraph"; // default to paragraph if type is not defined
			const outlineLevel = style["w:pPr"]?.[0]?.["w:outlineLvl"]?.[0]?.["$"]["w:val"];
			const id = style["$"]["w:styleId"];

			const typeMap = {
				paragraph: "p",
				character: "r",
				table: "table"
			};

			let fresh = ":fresh";
			let tag = "p";
			let type = typeMap[styleType];
			let className = "." + slugify(name);

			// Check if the style is a bullet or numbered list style
			const isBulletStyle = this.isBullet(id, numberingObject);
			if (isBulletStyle) {
				if (isBulletStyle["bulletType"] !== "bullet") {
					tag = repeatString("ol > li", isBulletStyle["level"], " > ");
				} else {
					tag = repeatString("ul > li", isBulletStyle["level"], " > ");
				}
			}

			// If the style is a heading, set the tag to h1, h2, etc. This overrides the bullet/numbered list style
			if (outlineLevel) {
				const headingLevel = parseInt(outlineLevel) + 1;
				tag = "h" + headingLevel;

				if (outlineLevel > 6) {
					tag = "p";
				}
			}

			// if the style is based on a built-in heading, set the tag to h1, h2, etc.
			const basedOn = style["w:basedOn"]?.[0]?.["$"]["w:val"];
			if (basedOn && !tag.startsWith("h")) {
				const isBasedOnHeading = basedOn.startsWith("Heading") || basedOn === "TOCHeading";

				if (isBasedOnHeading) {
					const headingLevel =
						basedOn !== "TOCHeading" ? parseInt(basedOn.replace("Heading", "")) : 2;
					tag = "h" + headingLevel;
				}
			}

			if (name === "TOC Heading") {
				tag = "h2";
			}

			// If the style is a character style, set the tag to span, em, or strong
			if (type === "r") {
				fresh = "";
				tag = "span";

				// ignore hyperlinks
				if (name.includes("Hyperlink")) {
					skipStyle = true;
				}

				if (name === "Emphasis") {
					tag = "em";
					className = "";
				}

				if (name === "Strong") {
					tag = "strong";
					className = "";
				}
			}

			if (type === "table") {
				tag = "table";
			}

			if (!skipStyle) {
				const mapItem = type + `[style-name='${name}']` + " => " + tag + className + fresh;
				styleMap.push(mapItem);
			}
		}

		return styleMap;
	}

	async getImageSizes() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		// read the document.xml file from the unzipped Word document
		/* == This code was generated by ChatGPT == */
		const documentXmlPath = this.unzippedFolder + "/word/document.xml";
		const xmlContent = fs.readFileSync(documentXmlPath, "utf-8");
		const parser = new xml2js.Parser({ explicitArray: false });
		const doc = await parser.parseStringPromise(xmlContent);

		const drawings = [];

		// Recursively search for drawings
		const traverse = (node) => {
			if (!node || typeof node !== "object") return;

			for (const key in node) {
				const child = node[key];

				if (key === "w:drawing") {
					const drawing = child["wp:inline"];
					const descr = drawing?.["wp:docPr"]?.$?.descr || "";

					const extent = drawing?.["wp:extent"]?.$;
					if (extent) {
						const cx = parseInt(extent.cx, 10);
						const cy = parseInt(extent.cy, 10);

						drawings.push({
							width: emuToPx(cx, 9025),
							height: emuToPx(cy, 9025),
							descr
						});
					}
				} else {
					traverse(child);
				}
			}
		};

		traverse(doc);

		return drawings;
		/* == end function == */
	}

	async generateCss() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		// read the styles.xml file from the unzipped Word document
		const parser = new xml2js.Parser();
		const stylesXmlPath = this.unzippedFolder + "/word/styles.xml";
		const stylesXmlContent = await fileSystem.readFile(stylesXmlPath);
		const stylesObject = await parser.parseStringPromise(stylesXmlContent);

		// read the document.xml file from the unzipped Word document
		const documentXmlPath = this.unzippedFolder + "/word/document.xml";
		const documentXmlContent = await fileSystem.readFile(documentXmlPath);

		// get all the paragraph styles from the document.xml file
		const paragraphStyles = new Set(["Normal"]); // add Normal style as default
		const $ = cheerio.load(documentXmlContent);
		$("w\\:pStyle").each((_, style) => {
			const styleId = $(style).attr("w:val");
			if (styleId) {
				paragraphStyles.add(styleId);
			}
		});

		// get all character styles from the document.xml file
		const characterStyles = new Set();
		$("w\\:rStyle").each((_, style) => {
			const styleId = $(style).attr("w:val");
			if (styleId) {
				characterStyles.add(styleId);
			}
		});

		// convert sets to arrays and join them
		const stylesArray = Array.from(paragraphStyles).concat(Array.from(characterStyles));

		const stylesCss = this.generateCssObjects(stylesArray, stylesObject);

		// create a CSS string from the stylesCss array
		const cssString = stylesCss
			.map((style) => {
				const cssString = Object.entries(style.css)
					.map(([property, value]) => `${property}: ${value};`)
					.join("\n\t");
				return `${style.selector} {\n\t${cssString}\n}`;
			})
			.join("\n");

		return cssString;
	}

	async convertToHtml(includeTemplate = false, templateData = {}, generateCss = false) {
		// create a folder in the downloads directory
		const outputFolder = await fileSystem.createFolder(
			"server/lib/html/" + this.filePath.split("/").pop().replace(".docx", "") + "_html"
		);

		// get image sizs of the images that are Inline with text
		const imageSizes = await this.getImageSizes();

		// generate a style map from the unzipped Word document
		const styleMap = await this.generateStyleMap();

		// configure mammoth options
		const options = {
			styleMap: styleMap,
			convertImage: await writeImageFiles(outputFolder, "images")
		};

		// convert the Word document to HTML
		const { value: htmlContent } = await mammoth.convertToHtml(
			{ path: this.filePath },
			options
		);

		const html = new Html("index.html", outputFolder, htmlContent, "images");
		await html.cleanUpWordToHtml(imageSizes);

		// if includeTemplate is true, add the HTML to the template
		let additionalHeaders = "</head>";

		if (includeTemplate) {
			const templatePath = "server/templates/word-to-html.html";
			const templateContent = await fileSystem.readFile(templatePath);
			const documentTitle = templateData.documentTitle || "";
			const favicon = templateData.favicon || null;

			if (favicon) {
				// copy the favicon to the html folder
				const ext = favicon.file.split(".").pop();
				const faviconFileName = "favicon." + ext;

				// move the favicon to the output folder
				await fileSystem.moveFile(
					favicon.folder + "/" + favicon.file,
					outputFolder + "/" + faviconFileName
				);

				// favicon link
				const faviconTypes = {
					png: "image/png",
					jpeg: "image/jpeg",
					jpg: "image/jpeg",
					ico: "image/x-icon"
				};
				const faviconLink = `<link rel="icon" href="${faviconFileName}" type="${faviconTypes[ext]}">`;

				additionalHeaders = faviconLink + additionalHeaders;
			}

			html.content = templateContent
				.replace("{title}", documentTitle)
				.replace("</head>", additionalHeaders)
				.replace("{content}", html.content);

			// write the HTML content to a file
			await html.writeFile();
		}

		// generate CSS from the unzipped Word document
		if (generateCss) {
			const css = await this.generateCss();
			await html.writeCssFile(css, "styles.css");
		}

		console.log("☑️ Word document converted to HTML");

		return html;
	}

	// #region helper functions

	// takes a styleId and the numberingXml object as input, and returns the bullet level if the style is a bullet/number list style
	isBullet(styleId, numberingObject) {
		for (const abstractNum of numberingObject["w:numbering"]["w:abstractNum"]) {
			if (abstractNum["w:lvl"]) {
				for (const lvl of abstractNum["w:lvl"]) {
					if (lvl["w:pStyle"] && lvl["w:pStyle"][0]["$"]["w:val"] === styleId) {
						return {
							level: parseInt(lvl["$"]["w:ilvl"]) + 1,
							bulletType: lvl["w:numFmt"][0]["$"]["w:val"]
						};
					}
				}
			}
		}

		return false;
	}

	getStyleData(styleId, stylesObjectFromXml) {
		const styleData = stylesObjectFromXml["w:styles"]["w:style"].find(
			(style) => style["$"]["w:styleId"] === styleId
		);

		return styleData;
	}

	getCssFromStyleData(style) {
		const css = {};

		// font size
		const fontSize = style["w:rPr"]?.[0]?.["w:sz"]?.[0]?.["$"]["w:val"];
		if (fontSize) {
			const fontSizePx = Math.round((fontSize / 2) * 1.33) + 1 + "px";
			css["font-size"] = fontSizePx;
		}

		// colour
		const colour = style["w:rPr"]?.[0]?.["w:color"]?.[0]?.["$"]["w:val"];
		if (colour) {
			if (colour === "auto") {
				css["color"] = "inherit"; // Use inherit for auto color
			} else {
				css["color"] = `#${colour}`;
			}
		}

		// margin and padding
		const spacingBefore = style["w:pPr"]?.[0]?.["w:spacing"]?.[0]?.["$"]["w:before"];
		if (spacingBefore) {
			const spacingBeforePx = Math.round((spacingBefore / 20) * 1.33) + "px";
			css["margin-top"] = spacingBeforePx;
		}

		const spacingAfter = style["w:pPr"]?.[0]?.["w:spacing"]?.[0]?.["$"]["w:after"];
		if (spacingAfter) {
			const spacingAfterPx = Math.round((spacingAfter / 20) * 1.33) + "px";
			css["margin-bottom"] = spacingAfterPx;
		}

		const leftIndent = style["w:pPr"]?.[0]?.["w:ind"]?.[0]?.["$"]["w:left"];
		if (leftIndent) {
			const leftIndentPx = Math.round((leftIndent / 20) * 1.33) + "px";
			css["margin-left"] = leftIndentPx;
		}

		// underline
		const underline = style["w:rPr"]?.[0]?.["w:u"]?.[0]?.["$"]["w:val"];
		if (underline) {
			css["text-decoration"] = "underline";
		}

		// bold
		const bold = style["w:rPr"]?.[0]?.["w:b"];
		if (bold) {
			css["font-weight"] = "bold";
		}

		// italic
		const italic = style["w:rPr"]?.[0]?.["w:i"];
		if (italic) {
			css["font-style"] = "italic";
		}

		// hanging
		const hanging = style["w:pPr"]?.[0]?.["w:ind"]?.[0]?.["$"]["w:hanging"];
		if (hanging) {
			const hangingPx = Math.round((hanging / 20) * 1.33) + "px";
			css["text-indent"] = `-${hangingPx}`;
		}

		// borders
		const borderBottom = style["w:pPr"]?.[0]?.["w:pBdr"]?.[0]?.["w:bottom"]?.[0]?.["$"];
		if (borderBottom) {
			const width = borderBottom["w:sz"]
				? Math.round((borderBottom["w:sz"] / 8) * 1.33) + "px"
				: "1px";

			const color =
				borderBottom["w:color"] !== "auto" ? `#${borderBottom["w:color"]}` : "black";

			css["border-bottom"] = `${width} solid ${color}`;
		}

		return css;
	}

	getListOfBasedOnStyles(styleId, stylesObjectFromXml, basedOnStyles = []) {
		const style = this.getStyleData(styleId, stylesObjectFromXml);

		if (style) {
			basedOnStyles.push(styleId); // Add current styleId to the list

			const basedOn = style["w:basedOn"]?.[0]?.["$"]["w:val"];
			if (basedOn) {
				return this.getListOfBasedOnStyles(basedOn, stylesObjectFromXml, basedOnStyles);
			}
		}

		return basedOnStyles;
	}

	generateCssObjects(styleIds, stylesObjectFromXml) {
		const styleCssObject = [];
		styleIds.forEach((id) => {
			const style = this.getStyleData(id, stylesObjectFromXml);

			if (style) {
				const name = style["w:name"][0]["$"]["w:val"];
				const className = slugify(name);
				const basedOnStyles = this.getListOfBasedOnStyles(id, stylesObjectFromXml);

				const cssObjects = [];
				basedOnStyles.reverse().forEach((basedOnId) => {
					const basedOnStyle = this.getStyleData(basedOnId, stylesObjectFromXml);
					const css = this.getCssFromStyleData(basedOnStyle);
					cssObjects.push(css);
				});

				// merge the CSS objects
				const css = Object.assign({}, ...cssObjects);

				// if styleId is hyperlink, add <a> tag
				let selector = "." + className;

				if (id === "Hyperlink") {
					selector = selector + ", a";
				}

				if (id.startsWith("TOC")) {
					css["display"] = "block";

					// check if css has 'text-decoration'
					if (!css["text-decoration"]) {
						css["text-decoration"] = "none"; // remove underline from toc a
					}

					styleCssObject.push({
						id,
						name,
						selector: selector + " a",
						css
					});

					return;
				}

				// if css object is not empty...
				if (Object.keys(css).length !== 0) {
					styleCssObject.push({
						id,
						name,
						selector,
						css
					});
				}
			}
		});

		return styleCssObject;
	}

	// #endregion
}

module.exports = WordDocument;
