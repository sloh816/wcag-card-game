const fileSystem = require("../utils/fileSystem");
const writeImageFiles = require("../utils/writeImageFiles");
const { slugify, repeatString } = require("../utils/strings");
const mammoth = require("mammoth");
const xml2js = require("xml2js");
const Html = require("./Html");
const fs = require("fs");
const cheerio = require("cheerio");
const emuToPx = require("../utils/emuToPx");

class WordDocument {
	constructor(filePath) {
		this.filePath = filePath;
		this.unzippedFolder = null;
	}

	async unzip() {
		// create a folder for the word document in the unzippedWordDocs directory
		const unzippedFolder = await fileSystem.createFolder(
			"server/lib/unzippedWordDocs/" + this.filePath.split("/").pop().replace(".docx", "")
		);

		// copy word doc to folder
		const wordDoc = await fileSystem.copyFile(
			this.filePath,
			unzippedFolder + "/" + this.filePath.split("/").pop()
		);

		// covert to zip file
		const zipFilePath = wordDoc.replace(".docx", ".zip");
		await fileSystem.renameFile(wordDoc, zipFilePath);

		// unzip the file
		await fileSystem.unzipFile(zipFilePath, unzippedFolder);

		// remove the zip file
		await fileSystem.deleteFile(zipFilePath);

		this.unzippedFolder = unzippedFolder;
	}

	async generateStyleMap() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		// read the styles.xml file from the unzipped Word document
		const stylesXml = await this.readXmlFile(this.unzippedFolder + "/word/styles.xml");
		const numberingXml = await this.readXmlFile(this.unzippedFolder + "/word/numbering.xml");

		const styles = stylesXml.object["w:styles"]["w:style"];

		const styleMap = [];
		for (const style of styles) {
			let skipStyle = false;

			const name = style["w:name"][0]["$"]["w:val"];
			const styleType = style["$"]["w:type"] || "paragraph"; // default to paragraph if type is not defined
			const outlineLevel = style["w:pPr"]?.[0]?.["w:outlineLvl"]?.[0]?.["$"]["w:val"];
			const id = style["$"]["w:styleId"];

			const typeMap = {
				paragraph: "p",
				character: "r",
				table: "table"
			};

			let fresh = ":fresh";
			let tag = "p";
			let type = typeMap[styleType];
			let className = "." + slugify(name);

			// Check if the style is a bullet or numbered list style
			const isBulletStyle = this.isBullet(id, numberingXml.object);
			if (isBulletStyle) {
				if (isBulletStyle["bulletType"] !== "bullet") {
					tag = repeatString("ol > li", isBulletStyle["level"], " > ");
				} else {
					tag = repeatString("ul > li", isBulletStyle["level"], " > ");
				}
			}

			// If the style is a heading, set the tag to h1, h2, etc. This overrides the bullet/numbered list style
			if (outlineLevel) {
				const headingLevel = parseInt(outlineLevel) + 1;
				tag = "h" + headingLevel;

				if (outlineLevel > 6) {
					tag = "p";
				}
			}

			// if the style is based on a built-in heading, set the tag to h1, h2, etc.
			const basedOn = style["w:basedOn"]?.[0]?.["$"]["w:val"];
			if (basedOn && !tag.startsWith("h")) {
				const isBasedOnHeading = basedOn.startsWith("Heading") || basedOn === "TOCHeading";

				if (isBasedOnHeading) {
					const headingLevel =
						basedOn !== "TOCHeading" ? parseInt(basedOn.replace("Heading", "")) : 2;
					tag = "h" + headingLevel;
				}
			}

			if (name === "TOC Heading") {
				tag = "h2";
			}

			if (className === ".spacer") {
				tag = "div";
			}

			// If the style is a character style, set the tag to span, em, or strong
			if (type === "r") {
				fresh = "";
				tag = "span";

				// ignore hyperlinks
				if (name.includes("Hyperlink")) {
					skipStyle = true;
				}

				if (name === "Emphasis") {
					tag = "em";
					className = "";
				}

				if (name === "Strong") {
					tag = "strong";
					className = "";
				}
			}

			if (type === "table") {
				tag = "table";
			}

			if (!skipStyle) {
				const mapItem = type + `[style-name='${name}']` + " => " + tag + className + fresh;
				styleMap.push(mapItem);
			}
		}

		return styleMap;
	}

	async getImageSizes() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		// read the document.xml file from the unzipped Word document
		/* == This code was generated by ChatGPT == */
		const documentXmlPath = this.unzippedFolder + "/word/document.xml";
		const xmlContent = fs.readFileSync(documentXmlPath, "utf-8");
		const parser = new xml2js.Parser({ explicitArray: false });
		const doc = await parser.parseStringPromise(xmlContent);

		const drawings = [];

		// Recursively search for drawings
		const traverse = (node) => {
			if (!node || typeof node !== "object") return;

			for (const key in node) {
				const child = node[key];

				if (key === "w:drawing") {
					const drawing = child["wp:inline"];
					const descr = drawing?.["wp:docPr"]?.$?.descr || "";

					const extent = drawing?.["wp:extent"]?.$;
					if (extent) {
						const cx = parseInt(extent.cx, 10);
						const cy = parseInt(extent.cy, 10);

						drawings.push({
							width: emuToPx(cx, 9025),
							height: emuToPx(cy, 9025),
							descr
						});
					}
				} else {
					traverse(child);
				}
			}
		};

		traverse(doc);

		return drawings;
		/* == end function == */
	}

	async generateCss() {
		if (!this.unzippedFolder) {
			await this.unzip();
		}

		try {
			// read the styles.xml file from the unzipped Word document
			const stylesXml = await this.readXmlFile(this.unzippedFolder + "/word/styles.xml");
			const documentXml = await this.readXmlFile(this.unzippedFolder + "/word/document.xml");
			const numberingXml = await this.readXmlFile(
				this.unzippedFolder + "/word/numbering.xml"
			);

			// get all the character and paragraph styles from the document.xml file
			const styleIdSet = new Set(["Normal"]); // add Normal style as default
			const $ = cheerio.load(documentXml.content);
			$("w\\:pStyle, w\\:rStyle").each((_, style) => {
				let styleId = $(style).attr("w:val");
				if (styleId) {
					// check if it's a bullet
					const isBullet = this.isBullet(styleId, numberingXml.object);
					if (isBullet && isBullet.bulletType === "decimal") {
						styleId += "---numberbullet";
					}

					styleIdSet.add(styleId);
				}
			});

			// get all the table styles from the document.xml file
			$("w\\:tblStyle").each((_, style) => {
				let styleId = $(style).attr("w:val");
				if (styleId) {
					styleIdSet.add(styleId + "---table");
				}
			});

			const styleIds = Array.from(styleIdSet);

			const stylesCss = this.generateCssObjects(styleIds, stylesXml.object);

			// create a CSS string from the stylesCss array
			const cssString = stylesCss
				.map((style) => {
					const cssString = Object.entries(style.css)
						.map(([property, value]) => `${property}: ${value};`)
						.join("\n\t");
					return `${style.selector} {\n\t${cssString}\n}`;
				})
				.join("\n");

			return cssString;
		} catch (error) {
			console.error("Error generating CSS:", error);
		}
	}

	async getFonts() {
		try {
			if (!this.unzippedFolder) {
				await this.unzip();
			}

			// check if it's a system font
			const systemFontsFile = await fileSystem.readFile("server/utils/systemFonts.json");
			const systemFonts = JSON.parse(systemFontsFile);

			// get the fonts used
			const stylesXml = await this.readXmlFile(this.unzippedFolder + "/word/styles.xml");

			const fontSet = new Set();
			for (const style of stylesXml.object["w:styles"]["w:style"]) {
				if (style["w:rPr"] && style["w:rPr"][0]["w:rFonts"]) {
					const rFonts = style["w:rPr"][0]["w:rFonts"][0]["$"];

					if (rFonts["w:ascii"]) {
						if (!systemFonts.includes(rFonts["w:ascii"])) {
							const isBold = style["w:rPr"][0]["w:b"] ? true : false;
							const isItalic = style["w:rPr"][0]["w:i"] ? true : false;
							const name = `${rFonts["w:ascii"]}`.trim();
							fontSet.add({ name, bold: isBold, italic: isItalic });
						}
					}
				}
			}

			return Array.from(fontSet);
		} catch (error) {
			console.error("Error getting fonts:", error);
		}
	}

	async convertToHtml(includeTemplate = false, templateData = {}, generateCss = false) {
		try {
			// create a folder in the downloads directory
			const outputFolder = await fileSystem.createFolder(
				"server/lib/html/" + this.filePath.split("/").pop().replace(".docx", "") + "_html"
			);

			// get image sizs of the images that are Inline with text
			const imageSizes = await this.getImageSizes();

			// generate a style map from the unzipped Word document
			const styleMap = await this.generateStyleMap();

			// configure mammoth options
			const options = {
				styleMap: styleMap,
				convertImage: await writeImageFiles(outputFolder, "images")
			};

			// convert the Word document to HTML
			const { value: htmlContent } = await mammoth.convertToHtml(
				{ path: this.filePath },
				options
			);

			const html = new Html("index.html", outputFolder, htmlContent, "images");
			await html.cleanUpWordToHtml(imageSizes);

			// if includeTemplate is true, add the HTML to the template
			let additionalHeaders = "</head>";

			if (includeTemplate) {
				const templatePath = "server/templates/word-to-html.html";
				const templateContent = await fileSystem.readFile(templatePath);
				const documentTitle = templateData.documentTitle || "";
				const favicon = templateData.favicon || null;

				if (favicon) {
					// copy the favicon to the html folder
					const ext = favicon.file.split(".").pop();
					const faviconFileName = "favicon." + ext;

					// move the favicon to the output folder
					await fileSystem.moveFile(
						favicon.folder + "/" + favicon.file,
						outputFolder + "/" + faviconFileName
					);

					// favicon link
					const faviconTypes = {
						png: "image/png",
						jpeg: "image/jpeg",
						jpg: "image/jpeg",
						ico: "image/x-icon"
					};
					const faviconLink = `<link rel="icon" href="${faviconFileName}" type="${faviconTypes[ext]}">`;

					additionalHeaders = faviconLink + additionalHeaders;
				}

				html.content = templateContent
					.replace("{title}", documentTitle)
					.replace("</head>", additionalHeaders)
					.replace("{content}", html.content);
			}

			// write the HTML content to a file
			await html.writeFile();

			// generate CSS from the unzipped Word document
			if (generateCss) {
				const css = await this.generateCss();
				html.cssContent = css;
				html.cssFile = "styles.css";
				await html.writeCssFile();
			}

			console.log("☑️ Word document converted to HTML");

			return html;
		} catch (error) {
			console.error("Error converting Word document to HTML:", error);
		}
	}

	// #region helper functions

	// takes a styleId and the numberingXml object as input, and returns the bullet level if the style is a bullet/number list style
	isBullet(styleId, numberingObject) {
		for (const abstractNum of numberingObject["w:numbering"]["w:abstractNum"]) {
			if (abstractNum["w:lvl"]) {
				for (const lvl of abstractNum["w:lvl"]) {
					if (lvl["w:pStyle"] && lvl["w:pStyle"][0]["$"]["w:val"] === styleId) {
						return {
							level: parseInt(lvl["$"]["w:ilvl"]) + 1,
							bulletType: lvl["w:numFmt"][0]["$"]["w:val"]
						};
					}
				}
			}
		}

		return false;
	}

	getStyleData(styleId, stylesObjectFromXml) {
		const styleData = stylesObjectFromXml["w:styles"]["w:style"].find(
			(style) => style["$"]["w:styleId"] === styleId
		);

		return styleData;
	}

	getCssFromStyleData(style) {
		const isTable = style["$"]["w:type"] === "table";

		const css = {};
		// margin and padding
		const spacingBefore = style["w:pPr"]?.[0]?.["w:spacing"]?.[0]?.["$"]["w:before"];
		if (spacingBefore) {
			const spacingBeforePx = Math.round((spacingBefore / 20) * 1.33) + "px";
			css["margin-top"] = spacingBeforePx;
		}

		const spacingAfter = style["w:pPr"]?.[0]?.["w:spacing"]?.[0]?.["$"]["w:after"];
		if (spacingAfter) {
			const spacingAfterPx = Math.round((spacingAfter / 20) * 1.33) + "px";
			css["margin-bottom"] = spacingAfterPx;
		}

		const leftIndent = style["w:pPr"]?.[0]?.["w:ind"]?.[0]?.["$"]["w:left"];
		if (leftIndent) {
			const leftIndentPx = Math.round((leftIndent / 20) * 1.33) + "px";
			css["margin-left"] = leftIndentPx;
		}

		// font size
		const fontSize = style["w:rPr"]?.[0]?.["w:sz"]?.[0]?.["$"]["w:val"];
		if (fontSize) {
			const fontSizePx = Math.round((fontSize / 2) * 1.33) + 1 + "px";
			css["font-size"] = fontSizePx;
		}

		// colour
		const colour = style["w:rPr"]?.[0]?.["w:color"]?.[0]?.["$"]["w:val"];
		if (colour) {
			css["color"] = this.colorFromWordColor(colour, "inherit");
		}

		// underline
		const underline = style["w:rPr"]?.[0]?.["w:u"]?.[0]?.["$"]["w:val"];
		if (underline) {
			css["text-decoration"] = "underline";
		}

		// bold
		const bold = style["w:rPr"]?.[0]?.["w:b"];
		if (bold) {
			css["font-weight"] = "bold";
		}

		// italic
		const italic = style["w:rPr"]?.[0]?.["w:i"];
		if (italic) {
			css["font-style"] = "italic";
		}

		// hanging
		const hanging = style["w:pPr"]?.[0]?.["w:ind"]?.[0]?.["$"]["w:hanging"];
		if (hanging) {
			const hangingPx = Math.round((hanging / 20) * 1.33) + "px";
			css["text-indent"] = `-${hangingPx}`;
		}

		// borders
		const borderBottom = style["w:pPr"]?.[0]?.["w:pBdr"]?.[0]?.["w:bottom"]?.[0]?.["$"];
		if (borderBottom) {
			const width = this.pxFromWordSz(borderBottom["w:sz"]);
			const color = this.colorFromWordColor(borderBottom["w:color"]);

			css["border-bottom"] = `${width} solid ${color}`;
		}

		// fonts
		const fontFamily = style["w:rPr"]?.[0]?.["w:rFonts"]?.[0]?.["$"]["w:ascii"];
		if (fontFamily) {
			css["font-family"] = `'${fontFamily.replace(/['"]/g, "")}'`;
		}

		if (isTable) {
			const getTableCssOject = (tableCss, childSelector) => {
				const existingStyle = tableCss.find((css) =>
					childSelector === ""
						? !css["child-selector"]
						: css["child-selector"] === childSelector
				);

				return {
					object: existingStyle ? existingStyle : { "child-selector": childSelector },
					exists: !!existingStyle,
					original: existingStyle ? existingStyle : {}
				};
			};

			const addToTableStyle = (tableCss, style) => {
				if (style.exists) {
					Object.assign(style.original, style.object);
				} else {
					tableCss.push(style.object);
				}
			};

			// console.dir(style, { depth: null });

			const tableCss = [];
			css["border-collapse"] = "collapse"; // Add border-collapse for tables
			css["width"] = "100%";
			tableCss.push(css);

			// add default table styles
			tableCss.push({
				"child-selector": "th",
				"text-align": "left"
			});

			// cell padding
			const hasCellMargin = style["w:tblPr"]?.[0]?.["w:tblCellMar"];
			if (hasCellMargin) {
				const tdStyle = getTableCssOject(tableCss, "td");

				const addCellPadding = (side) => {
					const cellMargin = hasCellMargin?.[0]?.[`w:${side}`]?.[0]?.["$"]["w:w"];
					if (cellMargin) {
						const cellMarginPx = Math.round((cellMargin / 20) * 1.33) + "px";
						tdStyle.object[`padding-${side}`] = cellMarginPx;
					}
				};

				addCellPadding("top");
				addCellPadding("bottom");
				addCellPadding("left");
				addCellPadding("right");

				// replace the existing td style or add a new one
				addToTableStyle(tableCss, tdStyle);
			}

			// table borders
			const hasTableBorders = style["w:tblPr"]?.[0]?.["w:tblBorders"];
			if (hasTableBorders) {
				const addBorderStyle = (side, selector, cssProperty) => {
					const style = getTableCssOject(tableCss, selector);
					const tableBorder = hasTableBorders[0][`w:${side}`]?.[0]?.["$"];
					if (tableBorder) {
						const width = this.pxFromWordSz(tableBorder["w:sz"]);
						const color = this.colorFromWordColor(tableBorder["w:color"]);
						style.object[cssProperty] = `${width} solid ${color}`;
						addToTableStyle(tableCss, style);
					}
				};

				addBorderStyle("bottom", "", "border-bottom");
				addBorderStyle("top", "", "border-top");
				addBorderStyle("left", "", "border-left");
				addBorderStyle("right", "", "border-right");
				addBorderStyle("insideH", "tr:not(:last-child) td", "border-bottom");
				addBorderStyle("insideV", "tr td:not(:last-child)", "border-right");
			}

			// heading styles
			const getTablePropObject = (type) => {
				const hasProperty = style["w:tblStylePr"]?.find(
					(property) => property["$"]?.["w:type"] === type
				);
				return hasProperty ? hasProperty : null;
			};

			const hasTableHeaderStyle = getTablePropObject("firstRow");
			if (hasTableHeaderStyle) {
				const thStyle = getTableCssOject(tableCss, "th");

				const textAlign = hasTableHeaderStyle["w:pPr"]?.[0]?.["w:jc"]?.[0]?.["$"]["w:val"];
				if (textAlign) {
					thStyle.object["text-align"] = textAlign;
				}

				const backgroundColor =
					hasTableHeaderStyle["w:tcPr"]?.[0]?.["w:shd"]?.[0]?.["$"]["w:fill"];
				if (backgroundColor) {
					thStyle.object["background-color"] = `#${backgroundColor}`;
				}

				const textColor =
					hasTableHeaderStyle["w:rPr"]?.[0]?.["w:color"]?.[0]?.["$"]["w:val"];
				if (textColor) {
					thStyle.object["color"] = `#${textColor}`;
				}

				const fontBold = hasTableHeaderStyle["w:rPr"]?.[0]?.["w:b"];
				if (fontBold) {
					thStyle.object["font-weight"] = "bold";
				} else {
					thStyle.object["font-weight"] = "normal";
				}

				addToTableStyle(tableCss, thStyle);
			}

			// band shading
			const hasOddBanding = getTablePropObject("band1Horz");
			if (hasOddBanding) {
				const rowStyle = getTableCssOject(tableCss, "tr:nth-child(odd)");
				// console.dir(hasOddBanding, { depth: null });
				const oddBandingStyle = hasOddBanding["w:tcPr"]?.[0]?.["w:shd"]?.[0]?.["$"];
				const backgroundColor = oddBandingStyle?.["w:fill"];
				rowStyle.object["background-color"] = `#${backgroundColor}`;
				addToTableStyle(tableCss, rowStyle);
			}

			const hasEvenBanding = getTablePropObject("band2Horz");
			if (hasEvenBanding) {
				const rowStyle = getTableCssOject(tableCss, "tr:nth-child(even)");
				const evenBandingStyle = hasEvenBanding["w:tcPr"]?.[0]?.["w:shd"]?.[0]?.["$"];
				const backgroundColor = evenBandingStyle?.["w:fill"];
				rowStyle.object["background-color"] = `#${backgroundColor}`;
				addToTableStyle(tableCss, rowStyle);
			}

			// first column
			const hasFirstColumn = getTablePropObject("firstCol");
			if (hasFirstColumn) {
				const firstColStyle = getTableCssOject(tableCss, "tr td:nth-child(1)");
				const isBold = hasFirstColumn["w:rPr"]?.[0]?.["w:b"];
				if (isBold) {
					firstColStyle.object["font-weight"] = "bold";
				} else {
					firstColStyle.object["font-weight"] = "normal";
				}

				addToTableStyle(tableCss, firstColStyle);
			}

			return tableCss;
		}

		return css;
	}

	getListOfBasedOnStyles(styleId, stylesObjectFromXml, basedOnStyles = []) {
		const style = this.getStyleData(styleId, stylesObjectFromXml);

		if (style) {
			basedOnStyles.push(styleId); // Add current styleId to the list

			const basedOn = style["w:basedOn"]?.[0]?.["$"]["w:val"];
			if (basedOn) {
				return this.getListOfBasedOnStyles(basedOn, stylesObjectFromXml, basedOnStyles);
			}
		}

		return basedOnStyles;
	}

	generateCssObjects(styleIds, stylesObjectFromXml) {
		const styleCssObject = [];
		styleIds.forEach((id) => {
			const isNumberList = id.endsWith("---numberbullet");
			const isTableStyle = id.endsWith("---table");

			if (isTableStyle) {
				id = id.replace("---table", "");
			}

			if (isNumberList) {
				id = id.replace("---numberbullet", "");
			}

			const style = this.getStyleData(id, stylesObjectFromXml);

			if (style) {
				const name = style["w:name"][0]["$"]["w:val"];
				const className = slugify(name);

				// Get a list of styles that this style is based on
				const basedOnStyles = this.getListOfBasedOnStyles(id, stylesObjectFromXml);

				// get the css object for each basedOn style and merge
				const cssObjects = [];
				basedOnStyles.reverse().forEach((basedOnId) => {
					const basedOnStyle = this.getStyleData(basedOnId, stylesObjectFromXml);
					const css = this.getCssFromStyleData(basedOnStyle);

					// if css is an array of objects, add each object to the cssObjects array
					cssObjects.push(css);
				});

				if (isTableStyle) {
					const mergedCssArray = this.mergeMultipleArraysByChildSelector(cssObjects);
					mergedCssArray.forEach((css) => {
						// if css object has a child-selector, add it to the selector
						const selector = css["child-selector"]
							? "." + className + " " + css["child-selector"]
							: "." + className;
						delete css["child-selector"]; // remove child-selector from the css object
						styleCssObject.push({
							id,
							name,
							selector,
							css: css
						});
					});
				} else {
					const css = Object.assign({}, ...cssObjects); // merge the CSS objects

					// if styleId is hyperlink, add <a> tag
					let selector = "." + className;

					if (id === "Hyperlink") {
						selector = selector + ", a:not([class^=toc] a)";
					}

					// if style is TOC, apply it to the <a> tag
					if (id.startsWith("TOC")) {
						css["display"] = "block";

						styleCssObject.push({
							id,
							name,
							selector: selector + " a",
							css
						});

						return;
					}

					// if style is spacer, calculate height based on margins and font size
					if (className === "spacer") {
						const marginTop = css["margin-top"].replace("px", "") || 0;
						const marginBottom = css["margin-bottom"].replace("px", "") || 0;
						const fontSize = css["font-size"].replace("px", "") || 0;

						const height =
							parseInt(marginTop) + parseInt(marginBottom) + parseInt(fontSize);

						delete css["margin-top"];
						delete css["margin-bottom"];
						delete css["font-size"];
						delete css["color"];

						css["height"] = height + "px";
						css["width"] = "100%";
					}

					// if is number bullet, apply text-indent to margin-left
					if (isNumberList) {
						const textIndent = css["text-indent"].replace("px", "") || 0;
						const marginLeft = css["margin-left"]
							? css["margin-left"].replace("px", "")
							: 0;

						const newMarginLeft = parseInt(marginLeft) + parseInt(textIndent) + "px";

						css["margin-left"] = newMarginLeft;
						delete css["text-indent"];
					}

					// if css object is not empty...
					if (Object.keys(css).length !== 0) {
						styleCssObject.push({
							id,
							name,
							selector,
							css
						});
					}
				}
			}
		});

		return styleCssObject;
	}

	async readXmlFile(filePath) {
		const parser = new xml2js.Parser();
		const xmlContent = await fileSystem.readFile(filePath);
		const object = await parser.parseStringPromise(xmlContent);

		return { object, content: xmlContent };
	}

	mergeMultipleArraysByChildSelector(arrayOfArrays) {
		const mergedMap = new Map();

		const addToMap = (obj) => {
			const key = obj["child-selector"] || "__no_selector__";
			if (!mergedMap.has(key)) {
				mergedMap.set(key, { ...obj });
			} else {
				Object.assign(mergedMap.get(key), obj);
			}
		};

		arrayOfArrays.flat().forEach(addToMap);

		return Array.from(mergedMap.values());
	}

	pxFromWordSz(sz, factor = 8) {
		return sz ? Math.round((sz / factor) * 1.33) + "px" : "1px";
	}

	colorFromWordColor(color, autoColor = "black") {
		return color !== "auto" ? `#${color}` : autoColor;
	}

	// #endregion
}

module.exports = WordDocument;
